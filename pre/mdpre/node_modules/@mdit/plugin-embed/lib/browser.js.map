{"version":3,"file":"browser.js","sources":["../../../node_modules/.pnpm/markdown-it@14.1.0/node_modules/markdown-it/lib/common/utils.mjs","../src/plugin.ts"],"sourcesContent":["// Utilities\n//\n\nimport * as mdurl from 'mdurl'\nimport * as ucmicro from 'uc.micro'\nimport { decodeHTML } from 'entities'\n\nfunction _class (obj) { return Object.prototype.toString.call(obj) }\n\nfunction isString (obj) { return _class(obj) === '[object String]' }\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty\n\nfunction has (object, key) {\n  return _hasOwnProperty.call(object, key)\n}\n\n// Merge objects\n//\nfunction assign (obj /* from1, from2, from3, ... */) {\n  const sources = Array.prototype.slice.call(arguments, 1)\n\n  sources.forEach(function (source) {\n    if (!source) { return }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object')\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key]\n    })\n  })\n\n  return obj\n}\n\n// Remove element from array and put another array at those position.\n// Useful for some operations with tokens\nfunction arrayReplaceAt (src, pos, newElements) {\n  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1))\n}\n\nfunction isValidEntityCode (c) {\n  /* eslint no-bitwise:0 */\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) { return false }\n  // never used\n  if (c >= 0xFDD0 && c <= 0xFDEF) { return false }\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false }\n  // control codes\n  if (c >= 0x00 && c <= 0x08) { return false }\n  if (c === 0x0B) { return false }\n  if (c >= 0x0E && c <= 0x1F) { return false }\n  if (c >= 0x7F && c <= 0x9F) { return false }\n  // out of range\n  if (c > 0x10FFFF) { return false }\n  return true\n}\n\nfunction fromCodePoint (c) {\n  /* eslint no-bitwise:0 */\n  if (c > 0xffff) {\n    c -= 0x10000\n    const surrogate1 = 0xd800 + (c >> 10)\n    const surrogate2 = 0xdc00 + (c & 0x3ff)\n\n    return String.fromCharCode(surrogate1, surrogate2)\n  }\n  return String.fromCharCode(c)\n}\n\nconst UNESCAPE_MD_RE  = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g\nconst ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi\nconst UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi')\n\nconst DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i\n\nfunction replaceEntityPattern (match, name) {\n  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    const code = name[1].toLowerCase() === 'x'\n      ? parseInt(name.slice(2), 16)\n      : parseInt(name.slice(1), 10)\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code)\n    }\n\n    return match\n  }\n\n  const decoded = decodeHTML(match)\n  if (decoded !== match) {\n    return decoded\n  }\n\n  return match\n}\n\n/* function replaceEntities(str) {\n  if (str.indexOf('&') < 0) { return str; }\n\n  return str.replace(ENTITY_RE, replaceEntityPattern);\n} */\n\nfunction unescapeMd (str) {\n  if (str.indexOf('\\\\') < 0) { return str }\n  return str.replace(UNESCAPE_MD_RE, '$1')\n}\n\nfunction unescapeAll (str) {\n  if (str.indexOf('\\\\') < 0 && str.indexOf('&') < 0) { return str }\n\n  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {\n    if (escaped) { return escaped }\n    return replaceEntityPattern(match, entity)\n  })\n}\n\nconst HTML_ESCAPE_TEST_RE = /[&<>\"]/\nconst HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g\nconst HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n}\n\nfunction replaceUnsafeChar (ch) {\n  return HTML_REPLACEMENTS[ch]\n}\n\nfunction escapeHtml (str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar)\n  }\n  return str\n}\n\nconst REGEXP_ESCAPE_RE = /[.?*+^$[\\]\\\\(){}|-]/g\n\nfunction escapeRE (str) {\n  return str.replace(REGEXP_ESCAPE_RE, '\\\\$&')\n}\n\nfunction isSpace (code) {\n  switch (code) {\n    case 0x09:\n    case 0x20:\n      return true\n  }\n  return false\n}\n\n// Zs (unicode class) || [\\t\\f\\v\\r\\n]\nfunction isWhiteSpace (code) {\n  if (code >= 0x2000 && code <= 0x200A) { return true }\n  switch (code) {\n    case 0x09: // \\t\n    case 0x0A: // \\n\n    case 0x0B: // \\v\n    case 0x0C: // \\f\n    case 0x0D: // \\r\n    case 0x20:\n    case 0xA0:\n    case 0x1680:\n    case 0x202F:\n    case 0x205F:\n    case 0x3000:\n      return true\n  }\n  return false\n}\n\n/* eslint-disable max-len */\n\n// Currently without astral characters support.\nfunction isPunctChar (ch) {\n  return ucmicro.P.test(ch) || ucmicro.S.test(ch)\n}\n\n// Markdown ASCII punctuation characters.\n//\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\n//\n// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.\n//\nfunction isMdAsciiPunct (ch) {\n  switch (ch) {\n    case 0x21/* ! */:\n    case 0x22/* \" */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x27/* ' */:\n    case 0x28/* ( */:\n    case 0x29/* ) */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2C/* , */:\n    case 0x2D/* - */:\n    case 0x2E/* . */:\n    case 0x2F/* / */:\n    case 0x3A/* : */:\n    case 0x3B/* ; */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x3F/* ? */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7C/* | */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true\n    default:\n      return false\n  }\n}\n\n// Hepler to unify [reference labels].\n//\nfunction normalizeReference (str) {\n  // Trim and collapse whitespace\n  //\n  str = str.trim().replace(/\\s+/g, ' ')\n\n  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug\n  // fixed in v12 (couldn't find any details).\n  //\n  // So treat this one as a special case\n  // (remove this when node v10 is no longer supported).\n  //\n  if ('ẞ'.toLowerCase() === 'Ṿ') {\n    str = str.replace(/ẞ/g, 'ß')\n  }\n\n  // .toLowerCase().toUpperCase() should get rid of all differences\n  // between letter variants.\n  //\n  // Simple .toLowerCase() doesn't normalize 125 code points correctly,\n  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:\n  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently\n  // uppercased versions).\n  //\n  // Here's an example showing how it happens. Lets take greek letter omega:\n  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)\n  //\n  // Unicode entries:\n  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;\n  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398\n  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398\n  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;\n  //\n  // Case-insensitive comparison should treat all of them as equivalent.\n  //\n  // But .toLowerCase() doesn't change ϑ (it's already lowercase),\n  // and .toUpperCase() doesn't change ϴ (already uppercase).\n  //\n  // Applying first lower then upper case normalizes any character:\n  // '\\u0398\\u03f4\\u03b8\\u03d1'.toLowerCase().toUpperCase() === '\\u0398\\u0398\\u0398\\u0398'\n  //\n  // Note: this is equivalent to unicode case folding; unicode normalization\n  // is a different step that is not required here.\n  //\n  // Final result should be uppercased, because it's later stored in an object\n  // (this avoid a conflict with Object.prototype members,\n  // most notably, `__proto__`)\n  //\n  return str.toLowerCase().toUpperCase()\n}\n\n// Re-export libraries commonly used in both markdown-it and its plugins,\n// so plugins won't have to depend on them explicitly, which reduces their\n// bundled size (e.g. a browser build).\n//\nconst lib = { mdurl, ucmicro }\n\nexport {\n  lib,\n  assign,\n  isString,\n  has,\n  unescapeMd,\n  unescapeAll,\n  isValidEntityCode,\n  fromCodePoint,\n  escapeHtml,\n  arrayReplaceAt,\n  isSpace,\n  isWhiteSpace,\n  isMdAsciiPunct,\n  isPunctChar,\n  escapeRE,\n  normalizeReference\n}\n","import type MarkdownIt from \"markdown-it\";\nimport type { PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { EmbedConfig, MarkdownItEmbedOptions } from \"./options.js\";\n\nconst checkInlineOpeningMarker = (src: string, current: number): boolean => {\n  if (\n    src.charCodeAt(current) !== 123 /* { */ ||\n    src.charCodeAt(current + 1) !== 37 /* % */\n  )\n    return false;\n\n  // Check if the opening marker was escaped\n  let pos = current - 1;\n  let backslashCount = 0;\n\n  while (pos >= 0 && src.charCodeAt(pos) === 92 /* \\ */) {\n    backslashCount++;\n    pos--;\n  }\n\n  // If opening {% is escaped (odd number of preceding backslashes), don't parse\n  if (backslashCount % 2 === 1) return false;\n\n  return true;\n};\n\nconst checkClosingMarker = (src: string, current: number): boolean =>\n  src.charCodeAt(current) === 37 /* % */ &&\n  src.charCodeAt(current + 1) === 125; /* } */\n\n/*\n * Parse inline embed with bracket syntax: {%...%}\n */\nconst getEmbedInline =\n  (inlineEmbedMap: Map<string, EmbedConfig>): RuleInline =>\n  (state, silent) => {\n    const start = state.pos;\n    const max = state.src.length;\n\n    // minimum length check for inline embed - at least 5 characters: {%x%}\n    if (max - start < 5) return false;\n\n    // check opening marker\n    if (!checkInlineOpeningMarker(state.src, start)) return false;\n\n    let contentStart = start + 2; // Move past the opening {% marker\n\n    // skip spaces\n    while (contentStart < max) {\n      if (!isSpace(state.src.charCodeAt(contentStart))) break;\n      contentStart++;\n    }\n\n    let contentEnd = contentStart;\n    let found = false;\n\n    for (; contentEnd + 1 < max; contentEnd++) {\n      // must not include opening marker\n      if (checkInlineOpeningMarker(state.src, contentEnd)) return false;\n      if (checkClosingMarker(state.src, contentEnd)) {\n        found = true;\n        break;\n      }\n    }\n\n    // No closing marker found\n    if (!found) return false;\n\n    // get first space\n    let spacer = contentStart + 1;\n\n    while (spacer < contentEnd) {\n      if (isSpace(state.src.charCodeAt(spacer))) break;\n      spacer++;\n    }\n\n    // Extract embed name\n    const name = state.src.slice(contentStart, spacer);\n\n    // Check if embed name exists in the map\n    if (!inlineEmbedMap.has(name)) return false;\n\n    if (!silent) {\n      const token = state.push(\"embed_inline\", \"embed\", 0);\n      const params = spacer\n        ? state.src\n            .slice(spacer + 1, contentEnd)\n            .trim()\n            .replace(/\\\\{%/g, \"{%\")\n            .replace(/%\\\\}/g, \"%}\")\n        : \"\";\n\n      token.markup = \"{% %}\";\n      token.info = name;\n      token.content = params;\n    }\n\n    // Move past the closing %} marker\n    state.pos = contentEnd + 2;\n\n    return true;\n  };\n\n/*\n * Parse block embed with syntax: {% ... %}\n */\nconst getEmbedBlock =\n  (embedMap: Map<string, EmbedConfig>): RuleBlock =>\n  (state, startLine, _, silent) => {\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n    const { src } = state;\n\n    // minimum length check for block embed - at least 5 characters: {%x%}\n    if (max - start < 5) return false;\n\n    // check opening marker\n    if (\n      state.src.charCodeAt(start) !== 123 /* { */ ||\n      state.src.charCodeAt(start + 1) !== 37 /* % */\n    )\n      return false;\n\n    max = state.skipSpacesBack(max, start);\n\n    const contentEnd = max - 2;\n\n    if (!checkClosingMarker(src, contentEnd)) return false;\n\n    let contentStart = start + 2;\n\n    // skip spaces\n    while (contentStart < contentEnd) {\n      if (!isSpace(state.src.charCodeAt(contentStart))) break;\n      contentStart++;\n    }\n\n    let spacer = -1;\n\n    for (let pos = contentStart; pos + 1 < contentEnd; pos++) {\n      // must not include unescaped opening marker or closing marker\n      if (checkInlineOpeningMarker(state.src, pos)) return false;\n      if (checkClosingMarker(state.src, pos)) return false;\n      if (spacer !== -1) continue;\n      if (isSpace(state.src.charCodeAt(pos))) spacer = pos;\n    }\n\n    // Extract content between {% and %}\n    const name =\n      spacer === -1\n        ? state.src.slice(contentStart, contentEnd + 1).trimEnd()\n        : state.src.slice(contentStart, spacer);\n\n    // Check if embed name exists in the map\n    if (!embedMap.has(name)) return false;\n\n    if (silent) return true;\n\n    const params =\n      spacer === -1\n        ? \"\"\n        : state.src\n            .slice(spacer + 1, contentEnd)\n            .trim()\n            .replace(/\\\\{%/g, \"{%\")\n            .replace(/%\\\\}/g, \"%}\");\n\n    const token = state.push(\"embed_block\", \"embed\", 0);\n\n    token.block = true;\n    token.info = name;\n    token.content = params;\n    token.map = [startLine, startLine + 1];\n    token.markup = \"{% %}\";\n\n    // Advance to the next line\n    state.line = startLine + 1;\n\n    return true;\n  };\n\nexport const embed: PluginWithOptions<MarkdownItEmbedOptions> = (\n  md,\n  options,\n) => {\n  if (typeof options !== \"object\" || !Array.isArray(options.config))\n    throw new Error(\n      \"[@mdit/plugin-embed]: config is required and must be an array.\",\n    );\n\n  // Get existing maps or create new ones to support multiple plugin instances\n  const mdWithMaps = md as MarkdownIt & {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    __embedMap?: Map<string, EmbedConfig>;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    __inlineEmbedMap?: Map<string, EmbedConfig>;\n  };\n\n  const embedMap = (mdWithMaps.__embedMap ??= new Map<string, EmbedConfig>());\n  const inlineEmbedMap = (mdWithMaps.__inlineEmbedMap ??= new Map<\n    string,\n    EmbedConfig\n  >());\n\n  options.config.forEach((item) => {\n    embedMap.set(item.name, item);\n    // Inline embeds are only supported when allowInline is true\n    if (item.allowInline) inlineEmbedMap.set(item.name, item);\n  });\n\n  // Only register rules if not already registered\n  // check embed_block rules here\n  if (!(\"embed_block\" in md.renderer.rules)) {\n    // Register the block rule\n    md.block.ruler.before(\"paragraph\", \"embed_block\", getEmbedBlock(embedMap), {\n      alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    });\n\n    // Register the renderers\n    md.renderer.rules.embed_block = (\n      tokens: Token[],\n      index: number,\n    ): string => {\n      const token = tokens[index];\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return embedMap.get(token.info)!.setup(token.content);\n    };\n  }\n\n  // only register embed_inline rules if inline embeds are allowed\n  if (inlineEmbedMap.size && !(\"embed_inline\" in md.renderer.rules)) {\n    // Register the inline rule\n    md.inline.ruler.before(\n      \"emphasis\",\n      \"embed_inline\",\n      getEmbedInline(inlineEmbedMap),\n    );\n\n    md.renderer.rules.embed_inline = (\n      tokens: Token[],\n      index: number,\n    ): string => {\n      const token = tokens[index];\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return inlineEmbedMap.get(token.info)!.setup(token.content);\n    };\n  }\n};\n"],"names":["isSpace","code","checkInlineOpeningMarker","src","current","pos","backslashCount","checkClosingMarker","getEmbedInline","inlineEmbedMap","state","silent","start","max","contentStart","contentEnd","found","spacer","name","token","params","getEmbedBlock","embedMap","startLine","_","embed","md","options","mdWithMaps","item","tokens","index"],"mappings":"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","x_google_ignoreList":[0]}