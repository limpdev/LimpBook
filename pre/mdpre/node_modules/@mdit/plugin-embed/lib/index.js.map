{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["import type MarkdownIt from \"markdown-it\";\nimport type { PluginWithOptions } from \"markdown-it\";\nimport { isSpace } from \"markdown-it/lib/common/utils.mjs\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.mjs\";\nimport type Token from \"markdown-it/lib/token.mjs\";\n\nimport type { EmbedConfig, MarkdownItEmbedOptions } from \"./options.js\";\n\nconst checkInlineOpeningMarker = (src: string, current: number): boolean => {\n  if (\n    src.charCodeAt(current) !== 123 /* { */ ||\n    src.charCodeAt(current + 1) !== 37 /* % */\n  )\n    return false;\n\n  // Check if the opening marker was escaped\n  let pos = current - 1;\n  let backslashCount = 0;\n\n  while (pos >= 0 && src.charCodeAt(pos) === 92 /* \\ */) {\n    backslashCount++;\n    pos--;\n  }\n\n  // If opening {% is escaped (odd number of preceding backslashes), don't parse\n  if (backslashCount % 2 === 1) return false;\n\n  return true;\n};\n\nconst checkClosingMarker = (src: string, current: number): boolean =>\n  src.charCodeAt(current) === 37 /* % */ &&\n  src.charCodeAt(current + 1) === 125; /* } */\n\n/*\n * Parse inline embed with bracket syntax: {%...%}\n */\nconst getEmbedInline =\n  (inlineEmbedMap: Map<string, EmbedConfig>): RuleInline =>\n  (state, silent) => {\n    const start = state.pos;\n    const max = state.src.length;\n\n    // minimum length check for inline embed - at least 5 characters: {%x%}\n    if (max - start < 5) return false;\n\n    // check opening marker\n    if (!checkInlineOpeningMarker(state.src, start)) return false;\n\n    let contentStart = start + 2; // Move past the opening {% marker\n\n    // skip spaces\n    while (contentStart < max) {\n      if (!isSpace(state.src.charCodeAt(contentStart))) break;\n      contentStart++;\n    }\n\n    let contentEnd = contentStart;\n    let found = false;\n\n    for (; contentEnd + 1 < max; contentEnd++) {\n      // must not include opening marker\n      if (checkInlineOpeningMarker(state.src, contentEnd)) return false;\n      if (checkClosingMarker(state.src, contentEnd)) {\n        found = true;\n        break;\n      }\n    }\n\n    // No closing marker found\n    if (!found) return false;\n\n    // get first space\n    let spacer = contentStart + 1;\n\n    while (spacer < contentEnd) {\n      if (isSpace(state.src.charCodeAt(spacer))) break;\n      spacer++;\n    }\n\n    // Extract embed name\n    const name = state.src.slice(contentStart, spacer);\n\n    // Check if embed name exists in the map\n    if (!inlineEmbedMap.has(name)) return false;\n\n    if (!silent) {\n      const token = state.push(\"embed_inline\", \"embed\", 0);\n      const params = spacer\n        ? state.src\n            .slice(spacer + 1, contentEnd)\n            .trim()\n            .replace(/\\\\{%/g, \"{%\")\n            .replace(/%\\\\}/g, \"%}\")\n        : \"\";\n\n      token.markup = \"{% %}\";\n      token.info = name;\n      token.content = params;\n    }\n\n    // Move past the closing %} marker\n    state.pos = contentEnd + 2;\n\n    return true;\n  };\n\n/*\n * Parse block embed with syntax: {% ... %}\n */\nconst getEmbedBlock =\n  (embedMap: Map<string, EmbedConfig>): RuleBlock =>\n  (state, startLine, _, silent) => {\n    const start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n    const { src } = state;\n\n    // minimum length check for block embed - at least 5 characters: {%x%}\n    if (max - start < 5) return false;\n\n    // check opening marker\n    if (\n      state.src.charCodeAt(start) !== 123 /* { */ ||\n      state.src.charCodeAt(start + 1) !== 37 /* % */\n    )\n      return false;\n\n    max = state.skipSpacesBack(max, start);\n\n    const contentEnd = max - 2;\n\n    if (!checkClosingMarker(src, contentEnd)) return false;\n\n    let contentStart = start + 2;\n\n    // skip spaces\n    while (contentStart < contentEnd) {\n      if (!isSpace(state.src.charCodeAt(contentStart))) break;\n      contentStart++;\n    }\n\n    let spacer = -1;\n\n    for (let pos = contentStart; pos + 1 < contentEnd; pos++) {\n      // must not include unescaped opening marker or closing marker\n      if (checkInlineOpeningMarker(state.src, pos)) return false;\n      if (checkClosingMarker(state.src, pos)) return false;\n      if (spacer !== -1) continue;\n      if (isSpace(state.src.charCodeAt(pos))) spacer = pos;\n    }\n\n    // Extract content between {% and %}\n    const name =\n      spacer === -1\n        ? state.src.slice(contentStart, contentEnd + 1).trimEnd()\n        : state.src.slice(contentStart, spacer);\n\n    // Check if embed name exists in the map\n    if (!embedMap.has(name)) return false;\n\n    if (silent) return true;\n\n    const params =\n      spacer === -1\n        ? \"\"\n        : state.src\n            .slice(spacer + 1, contentEnd)\n            .trim()\n            .replace(/\\\\{%/g, \"{%\")\n            .replace(/%\\\\}/g, \"%}\");\n\n    const token = state.push(\"embed_block\", \"embed\", 0);\n\n    token.block = true;\n    token.info = name;\n    token.content = params;\n    token.map = [startLine, startLine + 1];\n    token.markup = \"{% %}\";\n\n    // Advance to the next line\n    state.line = startLine + 1;\n\n    return true;\n  };\n\nexport const embed: PluginWithOptions<MarkdownItEmbedOptions> = (\n  md,\n  options,\n) => {\n  if (typeof options !== \"object\" || !Array.isArray(options.config))\n    throw new Error(\n      \"[@mdit/plugin-embed]: config is required and must be an array.\",\n    );\n\n  // Get existing maps or create new ones to support multiple plugin instances\n  const mdWithMaps = md as MarkdownIt & {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    __embedMap?: Map<string, EmbedConfig>;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    __inlineEmbedMap?: Map<string, EmbedConfig>;\n  };\n\n  const embedMap = (mdWithMaps.__embedMap ??= new Map<string, EmbedConfig>());\n  const inlineEmbedMap = (mdWithMaps.__inlineEmbedMap ??= new Map<\n    string,\n    EmbedConfig\n  >());\n\n  options.config.forEach((item) => {\n    embedMap.set(item.name, item);\n    // Inline embeds are only supported when allowInline is true\n    if (item.allowInline) inlineEmbedMap.set(item.name, item);\n  });\n\n  // Only register rules if not already registered\n  // check embed_block rules here\n  if (!(\"embed_block\" in md.renderer.rules)) {\n    // Register the block rule\n    md.block.ruler.before(\"paragraph\", \"embed_block\", getEmbedBlock(embedMap), {\n      alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n    });\n\n    // Register the renderers\n    md.renderer.rules.embed_block = (\n      tokens: Token[],\n      index: number,\n    ): string => {\n      const token = tokens[index];\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return embedMap.get(token.info)!.setup(token.content);\n    };\n  }\n\n  // only register embed_inline rules if inline embeds are allowed\n  if (inlineEmbedMap.size && !(\"embed_inline\" in md.renderer.rules)) {\n    // Register the inline rule\n    md.inline.ruler.before(\n      \"emphasis\",\n      \"embed_inline\",\n      getEmbedInline(inlineEmbedMap),\n    );\n\n    md.renderer.rules.embed_inline = (\n      tokens: Token[],\n      index: number,\n    ): string => {\n      const token = tokens[index];\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return inlineEmbedMap.get(token.info)!.setup(token.content);\n    };\n  }\n};\n"],"names":["checkInlineOpeningMarker","src","current","pos","backslashCount","checkClosingMarker","getEmbedInline","inlineEmbedMap","state","silent","start","max","contentStart","isSpace","contentEnd","found","spacer","name","token","params","getEmbedBlock","embedMap","startLine","_","embed","md","options","mdWithMaps","item","tokens","index"],"mappings":"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"}