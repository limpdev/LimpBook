{"version":3,"file":"index.js","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked and modified from https://github.com/markdown-it/markdown-it-deflist/blob/master/index.mjs\n */\n\nimport type { PluginSimple } from \"markdown-it\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.mjs\";\nimport type StateBlock from \"markdown-it/lib/rules_block/state_block.mjs\";\n\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nconst skipMarker = (state: StateBlock, line: number): number => {\n  let start = state.bMarks[line] + state.tShift[line];\n  const max = state.eMarks[line];\n\n  if (start >= max) return -1;\n\n  // Check bullet\n  const marker = state.src.charCodeAt(start++);\n\n  if (marker !== 126 /* ~ */ && marker !== 58 /* : */) return -1;\n\n  const pos = state.skipSpaces(start);\n\n  if (\n    // require space after \":\"\n    start === pos ||\n    // no empty definitions, e.g. \"  : \"\n    pos >= max\n  )\n    return -1;\n\n  return start;\n};\n\nconst markTightParagraphs = (state: StateBlock, index: number): void => {\n  const level = state.level + 2;\n\n  for (let i = index + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (\n      state.tokens[i].level === level &&\n      state.tokens[i].type === \"paragraph_open\"\n    ) {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n};\n\nconst dlRule: RuleBlock = (state, startLine, endLine, silent) => {\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole definition list\n    if (state.ddIndent < 0) return false;\n\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  let nextLine = startLine + 1;\n\n  if (nextLine >= endLine) return false;\n\n  if (state.isEmpty(nextLine)) {\n    nextLine++;\n    if (nextLine >= endLine) return false;\n  }\n\n  if (state.sCount[nextLine] < state.blkIndent) return false;\n\n  let contentStart = skipMarker(state, nextLine);\n\n  if (contentStart < 0) return false;\n\n  // Start list\n  const listTokIdx = state.tokens.length;\n\n  const dlOpenToken = state.push(\"dl_open\", \"dl\", 1);\n  const listLines: [start: number, end: number] = [startLine, 0];\n\n  dlOpenToken.map = listLines;\n\n  //\n  // Iterate list items\n  //\n\n  let dtLine = startLine;\n  let ddLine = nextLine;\n  let tight = true;\n\n  // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n  OUTER: for (;;) {\n    let prevEmptyEnd = false;\n\n    const dtOpenToken = state.push(\"dt_open\", \"dt\", 1);\n\n    dtOpenToken.map = [dtLine, dtLine];\n\n    const inlineToken = state.push(\"inline\", \"\", 0);\n\n    inlineToken.map = [dtLine, dtLine];\n    inlineToken.content = state\n      .getLines(dtLine, dtLine + 1, state.blkIndent, false)\n      .trim();\n    inlineToken.children = [];\n\n    state.push(\"dt_close\", \"dt\", -1);\n\n    for (;;) {\n      const ddOpenToken = state.push(\"dd_open\", \"dd\", 1);\n      const itemLines: [start: number, end: number] = [nextLine, 0];\n\n      ddOpenToken.map = itemLines;\n\n      let pos = contentStart;\n      const max = state.eMarks[ddLine];\n      let offset =\n        state.sCount[ddLine] +\n        contentStart -\n        (state.bMarks[ddLine] + state.tShift[ddLine]);\n\n      while (pos < max) {\n        const ch = state.src.charCodeAt(pos);\n\n        if (ch === 9 /* \\t */) offset += 4 - (offset % 4);\n        else if (ch === 32 /* space */) offset++;\n        else break;\n\n        pos++;\n      }\n\n      contentStart = pos;\n\n      const oldTight = state.tight;\n      const oldDDIndent = state.ddIndent;\n      const oldIndent = state.blkIndent;\n      const oldTShift = state.tShift[ddLine];\n      const oldSCount = state.sCount[ddLine];\n      const oldParentType = state.parentType;\n\n      state.blkIndent = state.ddIndent = state.sCount[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.sCount[ddLine] = offset;\n      state.tight = true;\n      // @ts-expect-error: This type is not standard\n      state.parentType = \"dl\";\n      // @ts-expect-error: An internal param is used\n      state.md.block.tokenize(state, ddLine, endLine, true);\n\n      // If any of list item is tight, mark list as tight\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!state.tight || prevEmptyEnd) tight = false;\n\n      // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n      prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n\n      state.tShift[ddLine] = oldTShift;\n      state.sCount[ddLine] = oldSCount;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n\n      state.push(\"dd_close\", \"dd\", -1);\n\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) break OUTER;\n\n      if (state.sCount[nextLine] < state.blkIndent) break OUTER;\n\n      contentStart = skipMarker(state, nextLine);\n\n      if (contentStart < 0) break;\n\n      ddLine = nextLine;\n\n      // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) break;\n\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine) || state.sCount[dtLine] < state.blkIndent) break;\n\n    ddLine = dtLine + 1;\n\n    if (ddLine >= endLine) break;\n\n    if (state.isEmpty(ddLine)) ddLine++;\n\n    if (ddLine >= endLine || state.sCount[ddLine] < state.blkIndent) break;\n\n    contentStart = skipMarker(state, ddLine);\n\n    if (contentStart < 0) break;\n\n    // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n  }\n\n  // Finalize list\n  state.push(\"dl_close\", \"dl\", -1);\n\n  listLines[1] = nextLine;\n\n  state.line = nextLine;\n\n  // mark paragraphs tight if needed\n  if (tight) markTightParagraphs(state, listTokIdx);\n\n  return true;\n};\n\nexport const dl: PluginSimple = (md) => {\n  md.block.ruler.before(\"paragraph\", \"dl\", dlRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\"],\n  });\n};\n"],"names":["skipMarker","state","line","start","max","marker","pos","markTightParagraphs","index","level","i","l","dlRule","startLine","endLine","silent","nextLine","contentStart","listTokIdx","dlOpenToken","listLines","dtLine","ddLine","tight","OUTER","prevEmptyEnd","dtOpenToken","inlineToken","ddOpenToken","itemLines","offset","ch","oldTight","oldDDIndent","oldIndent","oldTShift","oldSCount","oldParentType","dl","md"],"mappings":"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"}